# CVErt Ops — development stack
#
# Default (no profile): starts postgres + mailpit only.
# Run the application locally: go run ./cmd/cvert-ops serve
#
# Full container stack:
#   docker compose --profile app up -d
#
# Required env vars (set in ../.env or export before running):
#   POSTGRES_PASSWORD   — Postgres superuser password
#   JWT_SECRET          — ≥32 random bytes (required by serve/worker)
#
# Optional env vars (have sensible dev defaults):
#   POSTGRES_USER, POSTGRES_DB, POSTGRES_PORT
#   APP_PORT, MAILPIT_SMTP_PORT, MAILPIT_UI_PORT
#   APP_ENV, LOG_LEVEL, LOG_FORMAT, REGISTRATION_MODE
#   EXTERNAL_URL, COOKIE_SECURE, SHUTDOWN_TIMEOUT_SECONDS
#   CADDY_HOST, CADDY_HTTP_PORT, CADDY_HTTPS_PORT
#
# Network topology:
#   cvert-public-net  — Caddy ↔ App           (external internet access; feed APIs, ACME)
#   cvert-data-net    — App ↔ Postgres/Mailpit (internal=true; no outbound internet)
#   Caddy cannot reach Postgres or Mailpit. Migrate cannot be reached by Caddy.

# Internet ──► Caddy (cvert-public-net only)
#                 │  reverse_proxy
#                 ▼
#               App  (cvert-public-net + cvert-data-net)
#              ╱   ╲
#   Postgres ◄─     ─► Mailpit
#   (data only)         (data only)

# Migrate ◄──► Postgres  (data only, one-shot)

# Project name — sets the Docker Desktop stack label and container name prefix.
# container_name on each service removes the automatic -1 replica suffix.
name: cvert-ops

services:

  # ── Postgres ────────────────────────────────────────────────────────────────
  postgres:
    container_name: cvert-ops-postgres
    image: postgres:18-alpine
    environment:
      POSTGRES_DB:       ${POSTGRES_DB:-cvert_ops}
      POSTGRES_USER:     ${POSTGRES_USER:-cvert_ops}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD must be set in .env}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    networks:
      - cvert-data-net
    healthcheck:
      # pg_isready is included in the postgres:18-alpine image.
      # PLAN.md §18.3 requires service_healthy before app starts.
      test:
        - CMD-SHELL
        - pg_isready -U ${POSTGRES_USER:-cvert_ops} -d ${POSTGRES_DB:-cvert_ops}
      interval: 5s
      timeout: 5s
      retries: 10
      start_period: 10s
    restart: unless-stopped

  # ── Mailpit — local SMTP trap ────────────────────────────────────────────────
  mailpit:
    container_name: cvert-ops-mailpit
    image: axllent/mailpit:latest
    ports:
      - "${MAILPIT_SMTP_PORT:-1025}:1025"   # SMTP (app → mailpit)
      - "${MAILPIT_UI_PORT:-8025}:8025"     # Web UI: http://localhost:8025
    networks:
      - cvert-data-net
    environment:
      MP_SMTP_AUTH_ACCEPT_ANY:      1
      MP_SMTP_AUTH_ALLOW_INSECURE:  1
    restart: unless-stopped

  # ── Migrate — one-shot schema migration ─────────────────────────────────────
  # PLAN.md §18.3: run migrations as a separate command before the server starts;
  # the serve/worker subcommands must NOT call migrate.Up() automatically.
  migrate:
    container_name: cvert-ops-migrate
    build:
      context: ..
      dockerfile: docker/Dockerfile
    command: ["migrate"]
    environment:
      DATABASE_URL: >-
        postgresql://${POSTGRES_USER:-cvert_ops}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB:-cvert_ops}?sslmode=require
    networks:
      - cvert-data-net
    depends_on:
      postgres:
        condition: service_healthy
    # No restart — this is a one-shot job. The app service waits for it to exit 0.
    restart: "no"
    profiles: ["app"]

  # ── App — HTTP server + embedded worker pool ─────────────────────────────────
  app:
    container_name: cvert-ops-app
    build:
      context: ..
      dockerfile: docker/Dockerfile
    command: ["serve"]
    ports:
      - "${APP_PORT:-8080}:8080"
    networks:
      - cvert-public-net   # reachable by Caddy; outbound internet for feed adapters
      - cvert-data-net     # reaches Postgres and Mailpit
    environment:
      # Database
      DATABASE_URL: >-
        postgresql://${POSTGRES_USER:-cvert_ops}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB:-cvert_ops}?sslmode=require
      # PLAN.md §19.2: simple_protocol for PgBouncer compatibility (safe for direct connections too)
      DB_QUERY_EXEC_MODE: simple_protocol

      # Auth — JWT_SECRET is required; server exits at startup if missing or < 32 bytes
      JWT_SECRET: ${JWT_SECRET:?JWT_SECRET must be set in .env (min 32 random bytes)}

      # Server
      APP_ENV:                   ${APP_ENV:-development}
      # Caddy terminates TLS and forwards on :8080, so the external URL is HTTPS.
      # For go run (without Caddy) set EXTERNAL_URL=http://localhost:8080 in .env.
      EXTERNAL_URL:              ${EXTERNAL_URL:-https://localhost}
      # PLAN.md §7.1: COOKIE_SECURE=true because Caddy always serves HTTPS.
      # For go run (without Caddy) set COOKIE_SECURE=false in .env.
      COOKIE_SECURE:             ${COOKIE_SECURE:-true}
      REGISTRATION_MODE:         ${REGISTRATION_MODE:-open}
      SHUTDOWN_TIMEOUT_SECONDS:  ${SHUTDOWN_TIMEOUT_SECONDS:-60}

      # Logging
      LOG_LEVEL:  ${LOG_LEVEL:-debug}
      LOG_FORMAT: ${LOG_FORMAT:-text}

      # Email — route to mailpit in dev
      SMTP_HOST: mailpit
      SMTP_PORT: 1025

    depends_on:
      postgres:
        condition: service_healthy
      migrate:
        condition: service_completed_successfully
    restart: unless-stopped
    profiles: ["app"]

  # ── Caddy — TLS-terminating reverse proxy ────────────────────────────────────
  # Dev:  CADDY_HOST=localhost → HTTPS on :443 with Caddy's built-in local CA (self-signed).
  #       One-time setup to trust the CA in your OS / browser (run after first `up`):
  #         docker cp cvert-ops-caddy:/data/caddy/pki/authorities/local/root.crt caddy-root-ca.crt
  #       Then import caddy-root-ca.crt into your certificate store. The CA cert is
  #       stored in the caddy_data volume and reused across container restarts.
  # Prod: CADDY_HOST=cvert.example.com → Caddy auto-provisions TLS via Let's Encrypt.
  #       Also update EXTERNAL_URL=https://cvert.example.com and COOKIE_SECURE=true.
  caddy:
    container_name: cvert-ops-caddy
    image: caddy:2-alpine
    ports:
      - "${CADDY_HTTP_PORT:-80}:80"
      - "${CADDY_HTTPS_PORT:-443}:443"
    networks:
      - cvert-public-net   # reaches app; outbound internet for Let's Encrypt ACME
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data      # TLS certs + ACME state — must persist across restarts
      - caddy_config:/config  # Caddy internal config cache
    environment:
      CADDY_HOST: ${CADDY_HOST:-localhost}
    depends_on:
      - app
    restart: unless-stopped
    profiles: ["app"]

volumes:
  # Named volumes — data persists across container restarts and `docker compose down`.
  # Destroyed only by `docker compose down -v` or `docker volume rm`.
  postgres_data:
    driver: local
  caddy_data:
    driver: local
  caddy_config:
    driver: local

networks:
  # Front-end network: Caddy ↔ App. Has outbound internet access (feed APIs, Let's Encrypt).
  cvert-public-net:
    driver: bridge
  # Back-end data network: App ↔ Postgres/Mailpit. internal=true blocks outbound internet
  # for containers attached only to this network (postgres, mailpit, migrate).
  cvert-data-net:
    driver: bridge
    internal: true
