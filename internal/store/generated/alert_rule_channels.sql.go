// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: alert_rule_channels.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const bindChannelToRule = `-- name: BindChannelToRule :exec

INSERT INTO alert_rule_channels (rule_id, channel_id, org_id)
VALUES ($1, $2, $3)
ON CONFLICT (rule_id, channel_id) DO NOTHING
`

type BindChannelToRuleParams struct {
	RuleID    uuid.UUID
	ChannelID uuid.UUID
	OrgID     uuid.UUID
}

// ABOUTME: sqlc queries for alert rule â†” notification channel M:M bindings.
// ABOUTME: Hard-delete join table; no soft-delete.
func (q *Queries) BindChannelToRule(ctx context.Context, arg BindChannelToRuleParams) error {
	_, err := q.db.ExecContext(ctx, bindChannelToRule, arg.RuleID, arg.ChannelID, arg.OrgID)
	return err
}

const channelRuleBindingExists = `-- name: ChannelRuleBindingExists :one
SELECT EXISTS(
    SELECT 1 FROM alert_rule_channels
    WHERE rule_id = $1 AND channel_id = $2 AND org_id = $3
) AS exists
`

type ChannelRuleBindingExistsParams struct {
	RuleID    uuid.UUID
	ChannelID uuid.UUID
	OrgID     uuid.UUID
}

func (q *Queries) ChannelRuleBindingExists(ctx context.Context, arg ChannelRuleBindingExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, channelRuleBindingExists, arg.RuleID, arg.ChannelID, arg.OrgID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listActiveChannelsForFanout = `-- name: ListActiveChannelsForFanout :many
SELECT nc.id, nc.type, nc.config, nc.signing_secret, nc.signing_secret_secondary
FROM alert_rule_channels arc
JOIN notification_channels nc ON nc.id = arc.channel_id
WHERE arc.rule_id = $1 AND arc.org_id = $2
  AND nc.deleted_at IS NULL
`

type ListActiveChannelsForFanoutParams struct {
	RuleID uuid.UUID
	OrgID  uuid.UUID
}

type ListActiveChannelsForFanoutRow struct {
	ID                     uuid.UUID
	Type                   string
	Config                 json.RawMessage
	SigningSecret          string
	SigningSecretSecondary sql.NullString
}

// Used by Dispatcher.Fanout: fetches channel config + secrets for delivery row creation.
func (q *Queries) ListActiveChannelsForFanout(ctx context.Context, arg ListActiveChannelsForFanoutParams) ([]ListActiveChannelsForFanoutRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveChannelsForFanout, arg.RuleID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveChannelsForFanoutRow
	for rows.Next() {
		var i ListActiveChannelsForFanoutRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Config,
			&i.SigningSecret,
			&i.SigningSecretSecondary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannelsForRule = `-- name: ListChannelsForRule :many
SELECT nc.id, nc.org_id, nc.name, nc.type, nc.config, nc.created_at, nc.updated_at
FROM alert_rule_channels arc
JOIN notification_channels nc ON nc.id = arc.channel_id
WHERE arc.rule_id = $1 AND arc.org_id = $2
  AND nc.deleted_at IS NULL
ORDER BY arc.created_at
`

type ListChannelsForRuleParams struct {
	RuleID uuid.UUID
	OrgID  uuid.UUID
}

type ListChannelsForRuleRow struct {
	ID        uuid.UUID
	OrgID     uuid.UUID
	Name      string
	Type      string
	Config    json.RawMessage
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) ListChannelsForRule(ctx context.Context, arg ListChannelsForRuleParams) ([]ListChannelsForRuleRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannelsForRule, arg.RuleID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsForRuleRow
	for rows.Next() {
		var i ListChannelsForRuleRow
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Type,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unbindChannelFromRule = `-- name: UnbindChannelFromRule :exec
DELETE FROM alert_rule_channels
WHERE rule_id = $1 AND channel_id = $2 AND org_id = $3
`

type UnbindChannelFromRuleParams struct {
	RuleID    uuid.UUID
	ChannelID uuid.UUID
	OrgID     uuid.UUID
}

func (q *Queries) UnbindChannelFromRule(ctx context.Context, arg UnbindChannelFromRuleParams) error {
	_, err := q.db.ExecContext(ctx, unbindChannelFromRule, arg.RuleID, arg.ChannelID, arg.OrgID)
	return err
}
