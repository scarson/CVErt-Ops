// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: alert_rules.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createAlertRule = `-- name: CreateAlertRule :one

INSERT INTO alert_rules (
    org_id, name, logic, conditions, watchlist_ids, dsl_version,
    has_epss_condition, is_epss_only, status, fire_on_non_material_changes
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, org_id, name, logic, conditions, watchlist_ids, dsl_version, has_epss_condition, is_epss_only, status, fire_on_non_material_changes, created_at, updated_at, deleted_at
`

type CreateAlertRuleParams struct {
	OrgID                    uuid.UUID
	Name                     string
	Logic                    string
	Conditions               json.RawMessage
	WatchlistIds             []uuid.UUID
	DslVersion               int32
	HasEpssCondition         bool
	IsEpssOnly               bool
	Status                   string
	FireOnNonMaterialChanges bool
}

// ABOUTME: sqlc queries for alert rule, run, and event management.
// ABOUTME: Evaluator paths use bypass_rls worker transactions; HTTP paths use org-scoped transactions.
func (q *Queries) CreateAlertRule(ctx context.Context, arg CreateAlertRuleParams) (AlertRule, error) {
	row := q.db.QueryRowContext(ctx, createAlertRule,
		arg.OrgID,
		arg.Name,
		arg.Logic,
		arg.Conditions,
		pq.Array(arg.WatchlistIds),
		arg.DslVersion,
		arg.HasEpssCondition,
		arg.IsEpssOnly,
		arg.Status,
		arg.FireOnNonMaterialChanges,
	)
	var i AlertRule
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Logic,
		&i.Conditions,
		pq.Array(&i.WatchlistIds),
		&i.DslVersion,
		&i.HasEpssCondition,
		&i.IsEpssOnly,
		&i.Status,
		&i.FireOnNonMaterialChanges,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAlertRule = `-- name: GetAlertRule :one
SELECT id, org_id, name, logic, conditions, watchlist_ids, dsl_version, has_epss_condition, is_epss_only, status, fire_on_non_material_changes, created_at, updated_at, deleted_at FROM alert_rules
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type GetAlertRuleParams struct {
	ID    uuid.UUID
	OrgID uuid.UUID
}

func (q *Queries) GetAlertRule(ctx context.Context, arg GetAlertRuleParams) (AlertRule, error) {
	row := q.db.QueryRowContext(ctx, getAlertRule, arg.ID, arg.OrgID)
	var i AlertRule
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Logic,
		&i.Conditions,
		pq.Array(&i.WatchlistIds),
		&i.DslVersion,
		&i.HasEpssCondition,
		&i.IsEpssOnly,
		&i.Status,
		&i.FireOnNonMaterialChanges,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUnresolvedAlertEventCVEs = `-- name: GetUnresolvedAlertEventCVEs :many
SELECT cve_id FROM alert_events
WHERE rule_id = $1 AND org_id = $2 AND last_match_state = true
`

type GetUnresolvedAlertEventCVEsParams struct {
	RuleID uuid.UUID
	OrgID  uuid.UUID
}

// Returns CVE IDs of events that last matched for this rule, used for resolution detection.
func (q *Queries) GetUnresolvedAlertEventCVEs(ctx context.Context, arg GetUnresolvedAlertEventCVEsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUnresolvedAlertEventCVEs, arg.RuleID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var cve_id string
		if err := rows.Scan(&cve_id); err != nil {
			return nil, err
		}
		items = append(items, cve_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAlertEvent = `-- name: InsertAlertEvent :one
INSERT INTO alert_events (org_id, rule_id, cve_id, material_hash, last_match_state, suppress_delivery)
VALUES ($1, $2, $3, $4, true, $5)
ON CONFLICT (org_id, rule_id, cve_id, material_hash) DO NOTHING
RETURNING id
`

type InsertAlertEventParams struct {
	OrgID            uuid.UUID
	RuleID           uuid.UUID
	CveID            string
	MaterialHash     string
	SuppressDelivery bool
}

// Exactly-once insert: fan-out only when a new row is created.
// Returns the new row id; empty result means the event already existed (DO NOTHING).
func (q *Queries) InsertAlertEvent(ctx context.Context, arg InsertAlertEventParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertAlertEvent,
		arg.OrgID,
		arg.RuleID,
		arg.CveID,
		arg.MaterialHash,
		arg.SuppressDelivery,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertAlertRuleRun = `-- name: InsertAlertRuleRun :one
INSERT INTO alert_rule_runs (rule_id, org_id, path, status, started_at)
VALUES ($1, $2, $3, 'running', now())
RETURNING id, rule_id, org_id, path, status, started_at, finished_at, candidates_evaluated, matches_found, error_message
`

type InsertAlertRuleRunParams struct {
	RuleID uuid.UUID
	OrgID  uuid.UUID
	Path   string
}

func (q *Queries) InsertAlertRuleRun(ctx context.Context, arg InsertAlertRuleRunParams) (AlertRuleRun, error) {
	row := q.db.QueryRowContext(ctx, insertAlertRuleRun, arg.RuleID, arg.OrgID, arg.Path)
	var i AlertRuleRun
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.OrgID,
		&i.Path,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CandidatesEvaluated,
		&i.MatchesFound,
		&i.ErrorMessage,
	)
	return i, err
}

const listActiveRulesForEPSS = `-- name: ListActiveRulesForEPSS :many
SELECT id, org_id, name, logic, conditions, watchlist_ids, dsl_version, has_epss_condition, is_epss_only, status, fire_on_non_material_changes, created_at, updated_at, deleted_at FROM alert_rules
WHERE status = 'active' AND has_epss_condition = true AND deleted_at IS NULL
ORDER BY id
`

// Loads all active rules with EPSS conditions across all orgs for EPSS evaluation.
// Called from worker (bypass_rls); no org_id filter.
func (q *Queries) ListActiveRulesForEPSS(ctx context.Context) ([]AlertRule, error) {
	rows, err := q.db.QueryContext(ctx, listActiveRulesForEPSS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertRule
	for rows.Next() {
		var i AlertRule
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Logic,
			&i.Conditions,
			pq.Array(&i.WatchlistIds),
			&i.DslVersion,
			&i.HasEpssCondition,
			&i.IsEpssOnly,
			&i.Status,
			&i.FireOnNonMaterialChanges,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveRulesForEvaluation = `-- name: ListActiveRulesForEvaluation :many
SELECT id, org_id, name, logic, conditions, watchlist_ids, dsl_version, has_epss_condition, is_epss_only, status, fire_on_non_material_changes, created_at, updated_at, deleted_at FROM alert_rules
WHERE status = 'active' AND is_epss_only = false AND deleted_at IS NULL
ORDER BY id
`

// Loads all active non-EPSS-only rules across all orgs for realtime and batch evaluation.
// Called from worker (bypass_rls); no org_id filter.
func (q *Queries) ListActiveRulesForEvaluation(ctx context.Context) ([]AlertRule, error) {
	rows, err := q.db.QueryContext(ctx, listActiveRulesForEvaluation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertRule
	for rows.Next() {
		var i AlertRule
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Logic,
			&i.Conditions,
			pq.Array(&i.WatchlistIds),
			&i.DslVersion,
			&i.HasEpssCondition,
			&i.IsEpssOnly,
			&i.Status,
			&i.FireOnNonMaterialChanges,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveAlertEvent = `-- name: ResolveAlertEvent :exec
UPDATE alert_events
SET last_match_state = false
WHERE rule_id = $1 AND org_id = $2 AND cve_id = $3
`

type ResolveAlertEventParams struct {
	RuleID uuid.UUID
	OrgID  uuid.UUID
	CveID  string
}

// Marks a previously-matched event as no longer matching.
func (q *Queries) ResolveAlertEvent(ctx context.Context, arg ResolveAlertEventParams) error {
	_, err := q.db.ExecContext(ctx, resolveAlertEvent, arg.RuleID, arg.OrgID, arg.CveID)
	return err
}

const setAlertRuleStatus = `-- name: SetAlertRuleStatus :exec
UPDATE alert_rules
SET status     = $3,
    updated_at = now()
WHERE id = $1 AND org_id = $2
`

type SetAlertRuleStatusParams struct {
	ID     uuid.UUID
	OrgID  uuid.UUID
	Status string
}

func (q *Queries) SetAlertRuleStatus(ctx context.Context, arg SetAlertRuleStatusParams) error {
	_, err := q.db.ExecContext(ctx, setAlertRuleStatus, arg.ID, arg.OrgID, arg.Status)
	return err
}

const softDeleteAlertRule = `-- name: SoftDeleteAlertRule :exec
UPDATE alert_rules
SET deleted_at = now()
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
`

type SoftDeleteAlertRuleParams struct {
	ID    uuid.UUID
	OrgID uuid.UUID
}

func (q *Queries) SoftDeleteAlertRule(ctx context.Context, arg SoftDeleteAlertRuleParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteAlertRule, arg.ID, arg.OrgID)
	return err
}

const updateAlertRule = `-- name: UpdateAlertRule :one
UPDATE alert_rules
SET name                       = $3,
    logic                      = $4,
    conditions                 = $5,
    watchlist_ids              = $6,
    has_epss_condition         = $7,
    is_epss_only               = $8,
    fire_on_non_material_changes = $9,
    updated_at                 = now()
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
RETURNING id, org_id, name, logic, conditions, watchlist_ids, dsl_version, has_epss_condition, is_epss_only, status, fire_on_non_material_changes, created_at, updated_at, deleted_at
`

type UpdateAlertRuleParams struct {
	ID                       uuid.UUID
	OrgID                    uuid.UUID
	Name                     string
	Logic                    string
	Conditions               json.RawMessage
	WatchlistIds             []uuid.UUID
	HasEpssCondition         bool
	IsEpssOnly               bool
	FireOnNonMaterialChanges bool
}

// Updates mutable rule fields. has_epss_condition and is_epss_only are
// recomputed by the compiler on each DSL change and passed here.
func (q *Queries) UpdateAlertRule(ctx context.Context, arg UpdateAlertRuleParams) (AlertRule, error) {
	row := q.db.QueryRowContext(ctx, updateAlertRule,
		arg.ID,
		arg.OrgID,
		arg.Name,
		arg.Logic,
		arg.Conditions,
		pq.Array(arg.WatchlistIds),
		arg.HasEpssCondition,
		arg.IsEpssOnly,
		arg.FireOnNonMaterialChanges,
	)
	var i AlertRule
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Logic,
		&i.Conditions,
		pq.Array(&i.WatchlistIds),
		&i.DslVersion,
		&i.HasEpssCondition,
		&i.IsEpssOnly,
		&i.Status,
		&i.FireOnNonMaterialChanges,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateAlertRuleRun = `-- name: UpdateAlertRuleRun :exec
UPDATE alert_rule_runs
SET status               = $2,
    finished_at          = now(),
    candidates_evaluated = $3,
    matches_found        = $4,
    error_message        = $5
WHERE id = $1
`

type UpdateAlertRuleRunParams struct {
	ID                  uuid.UUID
	Status              string
	CandidatesEvaluated int32
	MatchesFound        int32
	ErrorMessage        sql.NullString
}

func (q *Queries) UpdateAlertRuleRun(ctx context.Context, arg UpdateAlertRuleRunParams) error {
	_, err := q.db.ExecContext(ctx, updateAlertRuleRun,
		arg.ID,
		arg.Status,
		arg.CandidatesEvaluated,
		arg.MatchesFound,
		arg.ErrorMessage,
	)
	return err
}
