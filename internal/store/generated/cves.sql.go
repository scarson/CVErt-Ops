// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cves.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const deleteCVEAffectedCPEs = `-- name: DeleteCVEAffectedCPEs :exec
DELETE FROM cve_affected_cpes WHERE cve_id = $1
`

// Delete all CPE rows before re-inserting in merge pipeline (§5.1).
func (q *Queries) DeleteCVEAffectedCPEs(ctx context.Context, cveID string) error {
	_, err := q.db.ExecContext(ctx, deleteCVEAffectedCPEs, cveID)
	return err
}

const deleteCVEAffectedPackages = `-- name: DeleteCVEAffectedPackages :exec
DELETE FROM cve_affected_packages WHERE cve_id = $1
`

// Delete all affected-package rows before re-inserting in merge pipeline (§5.1).
func (q *Queries) DeleteCVEAffectedPackages(ctx context.Context, cveID string) error {
	_, err := q.db.ExecContext(ctx, deleteCVEAffectedPackages, cveID)
	return err
}

const deleteCVEReferences = `-- name: DeleteCVEReferences :exec
DELETE FROM cve_references WHERE cve_id = $1
`

// Delete all reference rows before re-inserting in merge pipeline (§5.1).
func (q *Queries) DeleteCVEReferences(ctx context.Context, cveID string) error {
	_, err := q.db.ExecContext(ctx, deleteCVEReferences, cveID)
	return err
}

const deleteEPSSStaging = `-- name: DeleteEPSSStaging :exec
DELETE FROM epss_staging WHERE cve_id = $1
`

func (q *Queries) DeleteEPSSStaging(ctx context.Context, cveID string) error {
	_, err := q.db.ExecContext(ctx, deleteEPSSStaging, cveID)
	return err
}

const findCVEBySourceID = `-- name: FindCVEBySourceID :one
SELECT cve_id FROM cve_sources WHERE source_name = $1 AND source_id = $2 LIMIT 1
`

type FindCVEBySourceIDParams struct {
	SourceName string
	SourceID   sql.NullString
}

// Used for late-binding PK migration: find a CVE row stored under its native
// GHSA/OSV ID when a CVE alias has since been added (§3.2).
func (q *Queries) FindCVEBySourceID(ctx context.Context, arg FindCVEBySourceIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, findCVEBySourceID, arg.SourceName, arg.SourceID)
	var cve_id string
	err := row.Scan(&cve_id)
	return cve_id, err
}

const getAllCVESources = `-- name: GetAllCVESources :many
SELECT cve_id, source_name, source_id, normalized_json, source_date_modified, source_url, ingested_at FROM cve_sources WHERE cve_id = $1 ORDER BY source_name
`

func (q *Queries) GetAllCVESources(ctx context.Context, cveID string) ([]CveSource, error) {
	rows, err := q.db.QueryContext(ctx, getAllCVESources, cveID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CveSource
	for rows.Next() {
		var i CveSource
		if err := rows.Scan(
			&i.CveID,
			&i.SourceName,
			&i.SourceID,
			&i.NormalizedJson,
			&i.SourceDateModified,
			&i.SourceUrl,
			&i.IngestedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCVE = `-- name: GetCVE :one
SELECT cve_id, status, date_published, date_modified_source_max, date_modified_canonical, date_first_seen, description_primary, severity, cvss_v3_score, cvss_v3_vector, cvss_v3_source, cvss_v4_score, cvss_v4_vector, cvss_v4_source, cvss_score_diverges, cwe_ids, exploit_available, in_cisa_kev, epss_score, date_epss_updated, material_hash FROM cves WHERE cve_id = $1
`

func (q *Queries) GetCVE(ctx context.Context, cveID string) (Cfe, error) {
	row := q.db.QueryRowContext(ctx, getCVE, cveID)
	var i Cfe
	err := row.Scan(
		&i.CveID,
		&i.Status,
		&i.DatePublished,
		&i.DateModifiedSourceMax,
		&i.DateModifiedCanonical,
		&i.DateFirstSeen,
		&i.DescriptionPrimary,
		&i.Severity,
		&i.CvssV3Score,
		&i.CvssV3Vector,
		&i.CvssV3Source,
		&i.CvssV4Score,
		&i.CvssV4Vector,
		&i.CvssV4Source,
		&i.CvssScoreDiverges,
		pq.Array(&i.CweIds),
		&i.ExploitAvailable,
		&i.InCisaKev,
		&i.EpssScore,
		&i.DateEpssUpdated,
		&i.MaterialHash,
	)
	return i, err
}

const getCVEAffectedCPEs = `-- name: GetCVEAffectedCPEs :many
SELECT id, cve_id, cpe, cpe_normalized FROM cve_affected_cpes WHERE cve_id = $1 ORDER BY cpe_normalized
`

func (q *Queries) GetCVEAffectedCPEs(ctx context.Context, cveID string) ([]CveAffectedCpe, error) {
	rows, err := q.db.QueryContext(ctx, getCVEAffectedCPEs, cveID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CveAffectedCpe
	for rows.Next() {
		var i CveAffectedCpe
		if err := rows.Scan(
			&i.ID,
			&i.CveID,
			&i.Cpe,
			&i.CpeNormalized,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCVEAffectedPackages = `-- name: GetCVEAffectedPackages :many
SELECT id, cve_id, ecosystem, package_name, namespace, range_type, introduced, fixed, last_affected, events FROM cve_affected_packages WHERE cve_id = $1 ORDER BY ecosystem, package_name
`

func (q *Queries) GetCVEAffectedPackages(ctx context.Context, cveID string) ([]CveAffectedPackage, error) {
	rows, err := q.db.QueryContext(ctx, getCVEAffectedPackages, cveID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CveAffectedPackage
	for rows.Next() {
		var i CveAffectedPackage
		if err := rows.Scan(
			&i.ID,
			&i.CveID,
			&i.Ecosystem,
			&i.PackageName,
			&i.Namespace,
			&i.RangeType,
			&i.Introduced,
			&i.Fixed,
			&i.LastAffected,
			&i.Events,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCVEReferences = `-- name: GetCVEReferences :many
SELECT id, cve_id, url, url_canonical, tags FROM cve_references WHERE cve_id = $1 ORDER BY url_canonical
`

func (q *Queries) GetCVEReferences(ctx context.Context, cveID string) ([]CveReference, error) {
	rows, err := q.db.QueryContext(ctx, getCVEReferences, cveID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CveReference
	for rows.Next() {
		var i CveReference
		if err := rows.Scan(
			&i.ID,
			&i.CveID,
			&i.Url,
			&i.UrlCanonical,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCVESnapshot = `-- name: GetCVESnapshot :one
SELECT cve_id, severity, cvss_v3_score, cvss_v4_score, epss_score,
       description_primary, exploit_available, in_cisa_kev
FROM cves WHERE cve_id = $1
`

type GetCVESnapshotRow struct {
	CveID              string
	Severity           sql.NullString
	CvssV3Score        sql.NullFloat64
	CvssV4Score        sql.NullFloat64
	EpssScore          sql.NullFloat64
	DescriptionPrimary sql.NullString
	ExploitAvailable   bool
	InCisaKev          bool
}

// Returns the fields needed for alert delivery payloads.
func (q *Queries) GetCVESnapshot(ctx context.Context, cveID string) (GetCVESnapshotRow, error) {
	row := q.db.QueryRowContext(ctx, getCVESnapshot, cveID)
	var i GetCVESnapshotRow
	err := row.Scan(
		&i.CveID,
		&i.Severity,
		&i.CvssV3Score,
		&i.CvssV4Score,
		&i.EpssScore,
		&i.DescriptionPrimary,
		&i.ExploitAvailable,
		&i.InCisaKev,
	)
	return i, err
}

const getEPSSStaging = `-- name: GetEPSSStaging :one
SELECT cve_id, epss_score, as_of_date, ingested_at FROM epss_staging WHERE cve_id = $1
`

func (q *Queries) GetEPSSStaging(ctx context.Context, cveID string) (EpssStaging, error) {
	row := q.db.QueryRowContext(ctx, getEPSSStaging, cveID)
	var i EpssStaging
	err := row.Scan(
		&i.CveID,
		&i.EpssScore,
		&i.AsOfDate,
		&i.IngestedAt,
	)
	return i, err
}

const insertAffectedCPE = `-- name: InsertAffectedCPE :exec
INSERT INTO cve_affected_cpes (cve_id, cpe, cpe_normalized)
VALUES ($1, $2, $3)
ON CONFLICT (cve_id, cpe_normalized) DO NOTHING
`

type InsertAffectedCPEParams struct {
	CveID         string
	Cpe           string
	CpeNormalized string
}

func (q *Queries) InsertAffectedCPE(ctx context.Context, arg InsertAffectedCPEParams) error {
	_, err := q.db.ExecContext(ctx, insertAffectedCPE, arg.CveID, arg.Cpe, arg.CpeNormalized)
	return err
}

const insertAffectedPackage = `-- name: InsertAffectedPackage :exec
INSERT INTO cve_affected_packages (
    cve_id, ecosystem, package_name, namespace,
    range_type, introduced, fixed, last_affected, events
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type InsertAffectedPackageParams struct {
	CveID        string
	Ecosystem    string
	PackageName  string
	Namespace    sql.NullString
	RangeType    sql.NullString
	Introduced   sql.NullString
	Fixed        sql.NullString
	LastAffected sql.NullString
	Events       pqtype.NullRawMessage
}

func (q *Queries) InsertAffectedPackage(ctx context.Context, arg InsertAffectedPackageParams) error {
	_, err := q.db.ExecContext(ctx, insertAffectedPackage,
		arg.CveID,
		arg.Ecosystem,
		arg.PackageName,
		arg.Namespace,
		arg.RangeType,
		arg.Introduced,
		arg.Fixed,
		arg.LastAffected,
		arg.Events,
	)
	return err
}

const insertCVERawPayload = `-- name: InsertCVERawPayload :exec
INSERT INTO cve_raw_payloads (cve_id, source_name, payload)
VALUES ($1, $2, $3)
`

type InsertCVERawPayloadParams struct {
	CveID      string
	SourceName string
	Payload    json.RawMessage
}

func (q *Queries) InsertCVERawPayload(ctx context.Context, arg InsertCVERawPayloadParams) error {
	_, err := q.db.ExecContext(ctx, insertCVERawPayload, arg.CveID, arg.SourceName, arg.Payload)
	return err
}

const insertCVEReference = `-- name: InsertCVEReference :exec
INSERT INTO cve_references (cve_id, url, url_canonical, tags)
VALUES ($1, $2, $3, $4)
ON CONFLICT (cve_id, url_canonical) DO NOTHING
`

type InsertCVEReferenceParams struct {
	CveID        string
	Url          string
	UrlCanonical string
	Tags         []string
}

func (q *Queries) InsertCVEReference(ctx context.Context, arg InsertCVEReferenceParams) error {
	_, err := q.db.ExecContext(ctx, insertCVEReference,
		arg.CveID,
		arg.Url,
		arg.UrlCanonical,
		pq.Array(arg.Tags),
	)
	return err
}

const listCVEs = `-- name: ListCVEs :many
SELECT c.cve_id, c.status, c.date_published, c.date_modified_source_max, c.date_modified_canonical, c.date_first_seen, c.description_primary, c.severity, c.cvss_v3_score, c.cvss_v3_vector, c.cvss_v3_source, c.cvss_v4_score, c.cvss_v4_vector, c.cvss_v4_source, c.cvss_score_diverges, c.cwe_ids, c.exploit_available, c.in_cisa_kev, c.epss_score, c.date_epss_updated, c.material_hash
FROM cves c
ORDER BY c.date_modified_canonical DESC, c.cve_id
LIMIT $1 OFFSET $2
`

type ListCVEsParams struct {
	Limit  int32
	Offset int32
}

// Base list query — dynamic WHERE and ORDER BY built by squirrel in the
// store layer. This static query handles the no-filter paginated case.
func (q *Queries) ListCVEs(ctx context.Context, arg ListCVEsParams) ([]Cfe, error) {
	rows, err := q.db.QueryContext(ctx, listCVEs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cfe
	for rows.Next() {
		var i Cfe
		if err := rows.Scan(
			&i.CveID,
			&i.Status,
			&i.DatePublished,
			&i.DateModifiedSourceMax,
			&i.DateModifiedCanonical,
			&i.DateFirstSeen,
			&i.DescriptionPrimary,
			&i.Severity,
			&i.CvssV3Score,
			&i.CvssV3Vector,
			&i.CvssV3Source,
			&i.CvssV4Score,
			&i.CvssV4Vector,
			&i.CvssV4Source,
			&i.CvssScoreDiverges,
			pq.Array(&i.CweIds),
			&i.ExploitAvailable,
			&i.InCisaKev,
			&i.EpssScore,
			&i.DateEpssUpdated,
			&i.MaterialHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tombstoneCVE = `-- name: TombstoneCVE :exec
UPDATE cves
SET
    cvss_v3_score   = NULL,
    cvss_v3_vector  = NULL,
    cvss_v3_source  = NULL,
    cvss_v4_score   = NULL,
    cvss_v4_vector  = NULL,
    cvss_v4_source  = NULL,
    epss_score      = NULL,
    exploit_available = false,
    in_cisa_kev     = false
WHERE cve_id = $1
`

// Null out all computed fields for a rejected/withdrawn CVE (§5.1 tombstone).
func (q *Queries) TombstoneCVE(ctx context.Context, cveID string) error {
	_, err := q.db.ExecContext(ctx, tombstoneCVE, cveID)
	return err
}

const updateCVEEPSS = `-- name: UpdateCVEEPSS :exec
UPDATE cves
SET epss_score = $2, date_epss_updated = now()
WHERE cve_id = $1 AND epss_score IS DISTINCT FROM $2
`

type UpdateCVEEPSSParams struct {
	CveID     string
	EpssScore sql.NullFloat64
}

// Two-statement EPSS pattern step 1: update live CVE row if score changed.
func (q *Queries) UpdateCVEEPSS(ctx context.Context, arg UpdateCVEEPSSParams) error {
	_, err := q.db.ExecContext(ctx, updateCVEEPSS, arg.CveID, arg.EpssScore)
	return err
}

const upsertCVE = `-- name: UpsertCVE :exec
INSERT INTO cves (
    cve_id, status, date_published, date_modified_source_max,
    date_modified_canonical, date_first_seen, description_primary,
    severity, cvss_v3_score, cvss_v3_vector, cvss_v3_source,
    cvss_v4_score, cvss_v4_vector, cvss_v4_source, cvss_score_diverges,
    cwe_ids, exploit_available, in_cisa_kev, material_hash
)
VALUES (
    $1, $2, $3, $4,
    $5, now(), $6,
    $7, $8, $9, $10,
    $11, $12, $13, $14,
    $15, $16, $17, $18
)
ON CONFLICT (cve_id) DO UPDATE
    SET status                   = EXCLUDED.status,
        date_published           = EXCLUDED.date_published,
        date_modified_source_max = EXCLUDED.date_modified_source_max,
        date_modified_canonical  = EXCLUDED.date_modified_canonical,
        description_primary      = EXCLUDED.description_primary,
        severity                 = EXCLUDED.severity,
        cvss_v3_score            = EXCLUDED.cvss_v3_score,
        cvss_v3_vector           = EXCLUDED.cvss_v3_vector,
        cvss_v3_source           = EXCLUDED.cvss_v3_source,
        cvss_v4_score            = EXCLUDED.cvss_v4_score,
        cvss_v4_vector           = EXCLUDED.cvss_v4_vector,
        cvss_v4_source           = EXCLUDED.cvss_v4_source,
        cvss_score_diverges      = EXCLUDED.cvss_score_diverges,
        cwe_ids                  = EXCLUDED.cwe_ids,
        exploit_available        = EXCLUDED.exploit_available,
        in_cisa_kev              = EXCLUDED.in_cisa_kev,
        material_hash            = EXCLUDED.material_hash
    WHERE cves.material_hash IS DISTINCT FROM EXCLUDED.material_hash
`

type UpsertCVEParams struct {
	CveID                 string
	Status                sql.NullString
	DatePublished         sql.NullTime
	DateModifiedSourceMax sql.NullTime
	DateModifiedCanonical time.Time
	DescriptionPrimary    sql.NullString
	Severity              sql.NullString
	CvssV3Score           sql.NullFloat64
	CvssV3Vector          sql.NullString
	CvssV3Source          sql.NullString
	CvssV4Score           sql.NullFloat64
	CvssV4Vector          sql.NullString
	CvssV4Source          sql.NullString
	CvssScoreDiverges     bool
	CweIds                []string
	ExploitAvailable      bool
	InCisaKev             bool
	MaterialHash          sql.NullString
}

func (q *Queries) UpsertCVE(ctx context.Context, arg UpsertCVEParams) error {
	_, err := q.db.ExecContext(ctx, upsertCVE,
		arg.CveID,
		arg.Status,
		arg.DatePublished,
		arg.DateModifiedSourceMax,
		arg.DateModifiedCanonical,
		arg.DescriptionPrimary,
		arg.Severity,
		arg.CvssV3Score,
		arg.CvssV3Vector,
		arg.CvssV3Source,
		arg.CvssV4Score,
		arg.CvssV4Vector,
		arg.CvssV4Source,
		arg.CvssScoreDiverges,
		pq.Array(arg.CweIds),
		arg.ExploitAvailable,
		arg.InCisaKev,
		arg.MaterialHash,
	)
	return err
}

const upsertCVESearchIndex = `-- name: UpsertCVESearchIndex :exec
INSERT INTO cve_search_index (cve_id, fts_document)
VALUES (
    $1,
    setweight(to_tsvector('english', coalesce($2::text, '')), 'A') ||
    setweight(to_tsvector('english', coalesce($3::text, '')), 'B') ||
    setweight(to_tsvector('english', coalesce($4::text, '')), 'C') ||
    setweight(to_tsvector($1::text), 'D')
)
ON CONFLICT (cve_id) DO UPDATE
    SET fts_document = EXCLUDED.fts_document
    WHERE cve_search_index.fts_document IS DISTINCT FROM EXCLUDED.fts_document
`

type UpsertCVESearchIndexParams struct {
	CveID        string
	Description  string
	CweNames     string
	PackageNames string
}

// Weights: A=description (highest), B=CWE names, C=package names, D=CVE ID.
func (q *Queries) UpsertCVESearchIndex(ctx context.Context, arg UpsertCVESearchIndexParams) error {
	_, err := q.db.ExecContext(ctx, upsertCVESearchIndex,
		arg.CveID,
		arg.Description,
		arg.CweNames,
		arg.PackageNames,
	)
	return err
}

const upsertCVESource = `-- name: UpsertCVESource :exec
INSERT INTO cve_sources (cve_id, source_name, source_id, normalized_json, source_date_modified, source_url)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (cve_id, source_name) DO UPDATE
    SET source_id            = EXCLUDED.source_id,
        normalized_json      = EXCLUDED.normalized_json,
        source_date_modified = EXCLUDED.source_date_modified,
        source_url           = EXCLUDED.source_url,
        ingested_at          = now()
    WHERE cve_sources.normalized_json IS DISTINCT FROM EXCLUDED.normalized_json
`

type UpsertCVESourceParams struct {
	CveID              string
	SourceName         string
	SourceID           sql.NullString
	NormalizedJson     json.RawMessage
	SourceDateModified sql.NullTime
	SourceUrl          sql.NullString
}

func (q *Queries) UpsertCVESource(ctx context.Context, arg UpsertCVESourceParams) error {
	_, err := q.db.ExecContext(ctx, upsertCVESource,
		arg.CveID,
		arg.SourceName,
		arg.SourceID,
		arg.NormalizedJson,
		arg.SourceDateModified,
		arg.SourceUrl,
	)
	return err
}

const upsertEPSSStaging = `-- name: UpsertEPSSStaging :exec
INSERT INTO epss_staging (cve_id, epss_score, as_of_date)
SELECT t.cve_id, t.epss_score, t.as_of_date
FROM (VALUES ($1::text, $2::double precision, $3::date)) AS t(cve_id, epss_score, as_of_date)
WHERE NOT EXISTS (SELECT 1 FROM cves WHERE cve_id = t.cve_id)
ON CONFLICT (cve_id) DO UPDATE
    SET epss_score  = EXCLUDED.epss_score,
        as_of_date  = EXCLUDED.as_of_date,
        ingested_at = now()
    WHERE epss_staging.epss_score IS DISTINCT FROM EXCLUDED.epss_score
`

type UpsertEPSSStagingParams struct {
	Column1 string
	Column2 float64
	Column3 time.Time
}

// Two-statement EPSS pattern step 2 (pitfall §2.5/§2.6): insert staging row ONLY
// if the CVE does not yet exist in cves. DB-side WHERE NOT EXISTS eliminates the
// TOCTOU race and avoids application-side RowsAffected branching. Both this
// statement and UpdateCVEEPSS run unconditionally for every CSV row.
func (q *Queries) UpsertEPSSStaging(ctx context.Context, arg UpsertEPSSStagingParams) error {
	_, err := q.db.ExecContext(ctx, upsertEPSSStaging, arg.Column1, arg.Column2, arg.Column3)
	return err
}
