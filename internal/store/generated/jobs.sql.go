// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const claimJob = `-- name: ClaimJob :one
UPDATE job_queue
SET
    status    = 'running',
    locked_by = $2,
    locked_at = now(),
    attempts  = attempts + 1
WHERE id = (
    SELECT jq.id
    FROM job_queue jq
    WHERE jq.queue = $1
      AND jq.status = 'pending'
      AND jq.run_after <= now()
    ORDER BY jq.priority DESC, jq.created_at
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING id, queue, priority, payload, lock_key, status, run_after, attempts, max_attempts, locked_by, locked_at, created_at, finished_at, last_error
`

type ClaimJobParams struct {
	Queue    string
	LockedBy sql.NullString
}

// SKIP LOCKED: skip rows locked by other workers; returns nil if no job available.
// Atomically increments attempts and sets status=running in one round trip.
func (q *Queries) ClaimJob(ctx context.Context, arg ClaimJobParams) (JobQueue, error) {
	row := q.db.QueryRowContext(ctx, claimJob, arg.Queue, arg.LockedBy)
	var i JobQueue
	err := row.Scan(
		&i.ID,
		&i.Queue,
		&i.Priority,
		&i.Payload,
		&i.LockKey,
		&i.Status,
		&i.RunAfter,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LockedBy,
		&i.LockedAt,
		&i.CreatedAt,
		&i.FinishedAt,
		&i.LastError,
	)
	return i, err
}

const completeJob = `-- name: CompleteJob :exec
UPDATE job_queue
SET
    status      = 'succeeded',
    finished_at = now(),
    locked_by   = NULL,
    locked_at   = NULL
WHERE id = $1
`

func (q *Queries) CompleteJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, completeJob, id)
	return err
}

const enqueueJob = `-- name: EnqueueJob :one
INSERT INTO job_queue (queue, priority, payload, lock_key, max_attempts, run_after)
VALUES ($1, $2, $3, $4, $5, coalesce($6, now()))
RETURNING id
`

type EnqueueJobParams struct {
	Queue       string
	Priority    int32
	Payload     json.RawMessage
	LockKey     sql.NullString
	MaxAttempts int32
	Column6     interface{}
}

func (q *Queries) EnqueueJob(ctx context.Context, arg EnqueueJobParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, enqueueJob,
		arg.Queue,
		arg.Priority,
		arg.Payload,
		arg.LockKey,
		arg.MaxAttempts,
		arg.Column6,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const failJob = `-- name: FailJob :exec
UPDATE job_queue
SET
    last_error  = $2,
    locked_by   = NULL,
    locked_at   = NULL,
    status      = CASE
                      WHEN attempts >= max_attempts THEN 'dead'
                      ELSE 'pending'
                  END,
    run_after   = CASE
                      WHEN attempts >= max_attempts THEN run_after
                      ELSE now() + (power(2, attempts) * interval '1 second')
                  END,
    finished_at = CASE
                      WHEN attempts >= max_attempts THEN now()
                      ELSE NULL
                  END
WHERE id = $1
`

type FailJobParams struct {
	ID        uuid.UUID
	LastError sql.NullString
}

// Moves job to 'pending' with exponential backoff, or 'dead' if attempts exhausted.
// Note: attempts was already incremented by ClaimJob.
func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.ExecContext(ctx, failJob, arg.ID, arg.LastError)
	return err
}

const recoverStaleJobs = `-- name: RecoverStaleJobs :many
UPDATE job_queue
SET
    status    = 'pending',
    locked_by = NULL,
    locked_at = NULL
WHERE status = 'running'
  AND locked_at < now() - ($1 * INTERVAL '1 second')
RETURNING id, queue, lock_key
`

type RecoverStaleJobsRow struct {
	ID      uuid.UUID
	Queue   string
	LockKey sql.NullString
}

// Resets jobs stuck in 'running' state longer than the given number of seconds.
// Called by the stale-lock recovery goroutine every minute.
// $1 is the stale threshold in whole seconds (e.g. 300 = 5 minutes).
// Uses integer multiplication instead of ::interval cast â€” pgx sends int64
// as binary int8 which PostgreSQL cannot cast directly to interval (pitfall).
func (q *Queries) RecoverStaleJobs(ctx context.Context, dollar_1 interface{}) ([]RecoverStaleJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, recoverStaleJobs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecoverStaleJobsRow
	for rows.Next() {
		var i RecoverStaleJobsRow
		if err := rows.Scan(&i.ID, &i.Queue, &i.LockKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
