// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notification_deliveries.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const claimPendingDeliveries = `-- name: ClaimPendingDeliveries :many

SELECT id, org_id, rule_id, channel_id, attempt_count, payload
FROM notification_deliveries
WHERE status = 'pending' AND send_after <= now()
ORDER BY send_after
LIMIT $1
FOR UPDATE SKIP LOCKED
`

type ClaimPendingDeliveriesRow struct {
	ID           uuid.UUID
	OrgID        uuid.UUID
	RuleID       uuid.UUID
	ChannelID    uuid.UUID
	AttemptCount int32
	Payload      json.RawMessage
}

// ABOUTME: sqlc queries for the notification_deliveries delivery job queue.
// ABOUTME: Claim uses FOR UPDATE SKIP LOCKED; debounce uses ON CONFLICT partial index.
func (q *Queries) ClaimPendingDeliveries(ctx context.Context, limit int32) ([]ClaimPendingDeliveriesRow, error) {
	rows, err := q.db.QueryContext(ctx, claimPendingDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimPendingDeliveriesRow
	for rows.Next() {
		var i ClaimPendingDeliveriesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.RuleID,
			&i.ChannelID,
			&i.AttemptCount,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const completeDelivery = `-- name: CompleteDelivery :exec
UPDATE notification_deliveries
SET status = 'succeeded', delivered_at = now(), updated_at = now()
WHERE id = $1
`

func (q *Queries) CompleteDelivery(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, completeDelivery, id)
	return err
}

const exhaustDelivery = `-- name: ExhaustDelivery :exec
UPDATE notification_deliveries
SET status        = 'failed',
    attempt_count = attempt_count + 1,
    last_error    = $2,
    updated_at    = now()
WHERE id = $1
`

type ExhaustDeliveryParams struct {
	ID        uuid.UUID
	LastError sql.NullString
}

// Max attempts reached â€” move to permanent failure.
func (q *Queries) ExhaustDelivery(ctx context.Context, arg ExhaustDeliveryParams) error {
	_, err := q.db.ExecContext(ctx, exhaustDelivery, arg.ID, arg.LastError)
	return err
}

const getDelivery = `-- name: GetDelivery :one
SELECT id, org_id, rule_id, channel_id, status, attempt_count, payload,
       send_after, last_attempted_at, delivered_at, last_error, created_at, updated_at
FROM notification_deliveries
WHERE id = $1 AND org_id = $2
LIMIT 1
`

type GetDeliveryParams struct {
	ID    uuid.UUID
	OrgID uuid.UUID
}

func (q *Queries) GetDelivery(ctx context.Context, arg GetDeliveryParams) (NotificationDelivery, error) {
	row := q.db.QueryRowContext(ctx, getDelivery, arg.ID, arg.OrgID)
	var i NotificationDelivery
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.RuleID,
		&i.ChannelID,
		&i.Status,
		&i.AttemptCount,
		&i.Payload,
		&i.SendAfter,
		&i.LastAttemptedAt,
		&i.DeliveredAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDeliveries = `-- name: ListDeliveries :many
SELECT id, org_id, rule_id, channel_id, status, attempt_count,
       send_after, last_attempted_at, delivered_at, last_error, created_at, updated_at
FROM notification_deliveries
WHERE org_id = $1
  AND ($2::uuid IS NULL OR rule_id   = $2)
  AND ($3::uuid IS NULL OR channel_id = $3)
  AND ($4::text IS NULL OR status    = $4)
  AND (created_at < $5 OR (created_at = $5 AND id < $6))
ORDER BY created_at DESC, id DESC
LIMIT $7
`

type ListDeliveriesParams struct {
	OrgID     uuid.UUID
	Column2   uuid.UUID
	Column3   uuid.UUID
	Column4   string
	CreatedAt time.Time
	ID        uuid.UUID
	Limit     int32
}

type ListDeliveriesRow struct {
	ID              uuid.UUID
	OrgID           uuid.UUID
	RuleID          uuid.UUID
	ChannelID       uuid.UUID
	Status          string
	AttemptCount    int32
	SendAfter       time.Time
	LastAttemptedAt sql.NullTime
	DeliveredAt     sql.NullTime
	LastError       sql.NullString
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) ListDeliveries(ctx context.Context, arg ListDeliveriesParams) ([]ListDeliveriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listDeliveries,
		arg.OrgID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.CreatedAt,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeliveriesRow
	for rows.Next() {
		var i ListDeliveriesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.RuleID,
			&i.ChannelID,
			&i.Status,
			&i.AttemptCount,
			&i.SendAfter,
			&i.LastAttemptedAt,
			&i.DeliveredAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDeliveriesProcessing = `-- name: MarkDeliveriesProcessing :exec
UPDATE notification_deliveries
SET status = 'processing', last_attempted_at = now(), updated_at = now()
WHERE id = ANY($1::uuid[])
`

func (q *Queries) MarkDeliveriesProcessing(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, markDeliveriesProcessing, pq.Array(dollar_1))
	return err
}

const orphanedAlertEvents = `-- name: OrphanedAlertEvents :many
SELECT ae.org_id, ae.rule_id, ae.cve_id
FROM alert_events ae
WHERE ae.suppress_delivery = false
  AND ae.last_match_state  = true
  AND ae.first_fired_at < now() - interval '5 minutes'
  AND NOT EXISTS (
      SELECT 1
      FROM notification_deliveries nd
      WHERE nd.rule_id  = ae.rule_id
        AND nd.org_id   = ae.org_id
        AND nd.status   IN ('pending', 'processing', 'succeeded')
        AND nd.created_at >= ae.first_fired_at - interval '1 minute'
  )
LIMIT $1
`

type OrphanedAlertEventsRow struct {
	OrgID  uuid.UUID
	RuleID uuid.UUID
	CveID  string
}

// Recovery scan: alert_events with no corresponding delivery rows.
func (q *Queries) OrphanedAlertEvents(ctx context.Context, limit int32) ([]OrphanedAlertEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, orphanedAlertEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrphanedAlertEventsRow
	for rows.Next() {
		var i OrphanedAlertEventsRow
		if err := rows.Scan(&i.OrgID, &i.RuleID, &i.CveID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const replayDelivery = `-- name: ReplayDelivery :exec
UPDATE notification_deliveries
SET status        = 'pending',
    attempt_count = 0,
    send_after    = now(),
    last_error    = NULL,
    updated_at    = now()
WHERE id = $1 AND org_id = $2
  AND status IN ('failed', 'cancelled')
`

type ReplayDeliveryParams struct {
	ID    uuid.UUID
	OrgID uuid.UUID
}

func (q *Queries) ReplayDelivery(ctx context.Context, arg ReplayDeliveryParams) error {
	_, err := q.db.ExecContext(ctx, replayDelivery, arg.ID, arg.OrgID)
	return err
}

const resetStuckDeliveries = `-- name: ResetStuckDeliveries :exec
UPDATE notification_deliveries
SET status = 'pending', send_after = now(), updated_at = now()
WHERE status = 'processing'
  AND updated_at < now() - ($1 * interval '1 second')
`

// Recovery: reset processing rows that haven't been updated in $1 seconds.
func (q *Queries) ResetStuckDeliveries(ctx context.Context, dollar_1 interface{}) error {
	_, err := q.db.ExecContext(ctx, resetStuckDeliveries, dollar_1)
	return err
}

const retryDelivery = `-- name: RetryDelivery :exec
UPDATE notification_deliveries
SET status        = 'pending',
    attempt_count = attempt_count + 1,
    send_after    = now() + ($2 * interval '1 second'),
    last_error    = $3,
    updated_at    = now()
WHERE id = $1
`

type RetryDeliveryParams struct {
	ID        uuid.UUID
	Column2   interface{}
	LastError sql.NullString
}

// Sets status back to pending with incremented attempt_count and backoff send_after.
func (q *Queries) RetryDelivery(ctx context.Context, arg RetryDeliveryParams) error {
	_, err := q.db.ExecContext(ctx, retryDelivery, arg.ID, arg.Column2, arg.LastError)
	return err
}
