// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: report_channels.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const bindChannelToReport = `-- name: BindChannelToReport :exec

INSERT INTO report_channels (report_id, channel_id, org_id)
VALUES ($1, $2, $3)
ON CONFLICT (report_id, channel_id) DO NOTHING
`

type BindChannelToReportParams struct {
	ReportID  uuid.UUID
	ChannelID uuid.UUID
	OrgID     uuid.UUID
}

// ABOUTME: sqlc queries for scheduled report â†” notification channel M:M bindings.
// ABOUTME: Hard-delete join table; mirrors alert_rule_channels pattern.
func (q *Queries) BindChannelToReport(ctx context.Context, arg BindChannelToReportParams) error {
	_, err := q.db.ExecContext(ctx, bindChannelToReport, arg.ReportID, arg.ChannelID, arg.OrgID)
	return err
}

const channelHasActiveBoundReports = `-- name: ChannelHasActiveBoundReports :one
SELECT EXISTS(
    SELECT 1
    FROM report_channels rc
    JOIN scheduled_reports sr ON sr.id = rc.report_id
    WHERE rc.channel_id = $1
      AND sr.org_id = $2
      AND sr.status = 'active'
      AND sr.deleted_at IS NULL
) AS has_active_reports
`

type ChannelHasActiveBoundReportsParams struct {
	ChannelID uuid.UUID
	OrgID     uuid.UUID
}

// Pre-flight check before channel soft-delete.
func (q *Queries) ChannelHasActiveBoundReports(ctx context.Context, arg ChannelHasActiveBoundReportsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, channelHasActiveBoundReports, arg.ChannelID, arg.OrgID)
	var has_active_reports bool
	err := row.Scan(&has_active_reports)
	return has_active_reports, err
}

const listActiveChannelsForDigest = `-- name: ListActiveChannelsForDigest :many
SELECT nc.id, nc.type, nc.config, nc.signing_secret, nc.signing_secret_secondary
FROM report_channels rc
JOIN notification_channels nc ON nc.id = rc.channel_id
WHERE rc.report_id = $1 AND rc.org_id = $2
  AND nc.deleted_at IS NULL
`

type ListActiveChannelsForDigestParams struct {
	ReportID uuid.UUID
	OrgID    uuid.UUID
}

type ListActiveChannelsForDigestRow struct {
	ID                     uuid.UUID
	Type                   string
	Config                 json.RawMessage
	SigningSecret          sql.NullString
	SigningSecretSecondary sql.NullString
}

// Used by digest runner: fetches channel config + secrets for delivery creation.
func (q *Queries) ListActiveChannelsForDigest(ctx context.Context, arg ListActiveChannelsForDigestParams) ([]ListActiveChannelsForDigestRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveChannelsForDigest, arg.ReportID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveChannelsForDigestRow
	for rows.Next() {
		var i ListActiveChannelsForDigestRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Config,
			&i.SigningSecret,
			&i.SigningSecretSecondary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannelsForReport = `-- name: ListChannelsForReport :many
SELECT nc.id, nc.org_id, nc.name, nc.type, nc.config, nc.created_at, nc.updated_at
FROM report_channels rc
JOIN notification_channels nc ON nc.id = rc.channel_id
WHERE rc.report_id = $1 AND rc.org_id = $2
  AND nc.deleted_at IS NULL
ORDER BY rc.created_at
`

type ListChannelsForReportParams struct {
	ReportID uuid.UUID
	OrgID    uuid.UUID
}

type ListChannelsForReportRow struct {
	ID        uuid.UUID
	OrgID     uuid.UUID
	Name      string
	Type      string
	Config    json.RawMessage
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) ListChannelsForReport(ctx context.Context, arg ListChannelsForReportParams) ([]ListChannelsForReportRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannelsForReport, arg.ReportID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsForReportRow
	for rows.Next() {
		var i ListChannelsForReportRow
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Type,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reportChannelBindingExists = `-- name: ReportChannelBindingExists :one
SELECT EXISTS(
    SELECT 1 FROM report_channels
    WHERE report_id = $1 AND channel_id = $2 AND org_id = $3
) AS binding_exists
`

type ReportChannelBindingExistsParams struct {
	ReportID  uuid.UUID
	ChannelID uuid.UUID
	OrgID     uuid.UUID
}

func (q *Queries) ReportChannelBindingExists(ctx context.Context, arg ReportChannelBindingExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, reportChannelBindingExists, arg.ReportID, arg.ChannelID, arg.OrgID)
	var binding_exists bool
	err := row.Scan(&binding_exists)
	return binding_exists, err
}

const unbindChannelFromReport = `-- name: UnbindChannelFromReport :exec
DELETE FROM report_channels
WHERE report_id = $1 AND channel_id = $2 AND org_id = $3
`

type UnbindChannelFromReportParams struct {
	ReportID  uuid.UUID
	ChannelID uuid.UUID
	OrgID     uuid.UUID
}

func (q *Queries) UnbindChannelFromReport(ctx context.Context, arg UnbindChannelFromReportParams) error {
	_, err := q.db.ExecContext(ctx, unbindChannelFromReport, arg.ReportID, arg.ChannelID, arg.OrgID)
	return err
}
