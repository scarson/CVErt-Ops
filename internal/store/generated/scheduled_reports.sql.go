// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scheduled_reports.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const advanceReport = `-- name: AdvanceReport :exec
UPDATE scheduled_reports
SET last_run_at = $2,
    next_run_at = $3,
    updated_at  = now()
WHERE id = $1
`

type AdvanceReportParams struct {
	ID        uuid.UUID
	LastRunAt sql.NullTime
	NextRunAt time.Time
}

// After a digest run: update last_run_at and next_run_at.
func (q *Queries) AdvanceReport(ctx context.Context, arg AdvanceReportParams) error {
	_, err := q.db.ExecContext(ctx, advanceReport, arg.ID, arg.LastRunAt, arg.NextRunAt)
	return err
}

const claimDueReports = `-- name: ClaimDueReports :many
SELECT id, org_id, name, scheduled_time, timezone, next_run_at, last_run_at, severity_threshold, watchlist_ids, send_on_empty, ai_summary, status, deleted_at, created_at, updated_at FROM scheduled_reports
WHERE status = 'active'
  AND next_run_at <= now()
  AND deleted_at IS NULL
ORDER BY next_run_at
LIMIT $1
FOR UPDATE SKIP LOCKED
`

// Digest runner: claim up to $1 reports that are due for execution.
func (q *Queries) ClaimDueReports(ctx context.Context, limit int32) ([]ScheduledReport, error) {
	rows, err := q.db.QueryContext(ctx, claimDueReports, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledReport
	for rows.Next() {
		var i ScheduledReport
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.ScheduledTime,
			&i.Timezone,
			&i.NextRunAt,
			&i.LastRunAt,
			&i.SeverityThreshold,
			pq.Array(&i.WatchlistIds),
			&i.SendOnEmpty,
			&i.AiSummary,
			&i.Status,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createScheduledReport = `-- name: CreateScheduledReport :one

INSERT INTO scheduled_reports (
    org_id, name, scheduled_time, timezone, next_run_at,
    severity_threshold, watchlist_ids, send_on_empty, ai_summary, status
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, org_id, name, scheduled_time, timezone, next_run_at, last_run_at, severity_threshold, watchlist_ids, send_on_empty, ai_summary, status, deleted_at, created_at, updated_at
`

type CreateScheduledReportParams struct {
	OrgID             uuid.UUID
	Name              string
	ScheduledTime     string
	Timezone          string
	NextRunAt         time.Time
	SeverityThreshold sql.NullString
	WatchlistIds      []uuid.UUID
	SendOnEmpty       bool
	AiSummary         bool
	Status            string
}

// ABOUTME: sqlc queries for scheduled_reports digest configuration CRUD.
// ABOUTME: Runner ops (claim, advance) use bypass-RLS. API ops use org-scoped tx.
func (q *Queries) CreateScheduledReport(ctx context.Context, arg CreateScheduledReportParams) (ScheduledReport, error) {
	row := q.db.QueryRowContext(ctx, createScheduledReport,
		arg.OrgID,
		arg.Name,
		arg.ScheduledTime,
		arg.Timezone,
		arg.NextRunAt,
		arg.SeverityThreshold,
		pq.Array(arg.WatchlistIds),
		arg.SendOnEmpty,
		arg.AiSummary,
		arg.Status,
	)
	var i ScheduledReport
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.ScheduledTime,
		&i.Timezone,
		&i.NextRunAt,
		&i.LastRunAt,
		&i.SeverityThreshold,
		pq.Array(&i.WatchlistIds),
		&i.SendOnEmpty,
		&i.AiSummary,
		&i.Status,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlertRuleName = `-- name: GetAlertRuleName :one
SELECT name FROM alert_rules WHERE id = $1 LIMIT 1
`

// Lightweight lookup for template rendering.
func (q *Queries) GetAlertRuleName(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getAlertRuleName, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getScheduledReport = `-- name: GetScheduledReport :one
SELECT id, org_id, name, scheduled_time, timezone, next_run_at, last_run_at, severity_threshold, watchlist_ids, send_on_empty, ai_summary, status, deleted_at, created_at, updated_at FROM scheduled_reports
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type GetScheduledReportParams struct {
	ID    uuid.UUID
	OrgID uuid.UUID
}

func (q *Queries) GetScheduledReport(ctx context.Context, arg GetScheduledReportParams) (ScheduledReport, error) {
	row := q.db.QueryRowContext(ctx, getScheduledReport, arg.ID, arg.OrgID)
	var i ScheduledReport
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.ScheduledTime,
		&i.Timezone,
		&i.NextRunAt,
		&i.LastRunAt,
		&i.SeverityThreshold,
		pq.Array(&i.WatchlistIds),
		&i.SendOnEmpty,
		&i.AiSummary,
		&i.Status,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listScheduledReports = `-- name: ListScheduledReports :many
SELECT id, org_id, name, scheduled_time, timezone, next_run_at, last_run_at, severity_threshold, watchlist_ids, send_on_empty, ai_summary, status, deleted_at, created_at, updated_at FROM scheduled_reports
WHERE org_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC, id DESC
`

func (q *Queries) ListScheduledReports(ctx context.Context, orgID uuid.UUID) ([]ScheduledReport, error) {
	rows, err := q.db.QueryContext(ctx, listScheduledReports, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduledReport
	for rows.Next() {
		var i ScheduledReport
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.ScheduledTime,
			&i.Timezone,
			&i.NextRunAt,
			&i.LastRunAt,
			&i.SeverityThreshold,
			pq.Array(&i.WatchlistIds),
			&i.SendOnEmpty,
			&i.AiSummary,
			&i.Status,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteScheduledReport = `-- name: SoftDeleteScheduledReport :exec
UPDATE scheduled_reports
SET deleted_at = now(), updated_at = now()
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
`

type SoftDeleteScheduledReportParams struct {
	ID    uuid.UUID
	OrgID uuid.UUID
}

func (q *Queries) SoftDeleteScheduledReport(ctx context.Context, arg SoftDeleteScheduledReportParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteScheduledReport, arg.ID, arg.OrgID)
	return err
}

const updateScheduledReport = `-- name: UpdateScheduledReport :one
UPDATE scheduled_reports
SET name               = $3,
    scheduled_time     = $4,
    timezone           = $5,
    next_run_at        = $6,
    severity_threshold = $7,
    watchlist_ids      = $8,
    send_on_empty      = $9,
    ai_summary         = $10,
    status             = $11,
    updated_at         = now()
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
RETURNING id, org_id, name, scheduled_time, timezone, next_run_at, last_run_at, severity_threshold, watchlist_ids, send_on_empty, ai_summary, status, deleted_at, created_at, updated_at
`

type UpdateScheduledReportParams struct {
	ID                uuid.UUID
	OrgID             uuid.UUID
	Name              string
	ScheduledTime     string
	Timezone          string
	NextRunAt         time.Time
	SeverityThreshold sql.NullString
	WatchlistIds      []uuid.UUID
	SendOnEmpty       bool
	AiSummary         bool
	Status            string
}

func (q *Queries) UpdateScheduledReport(ctx context.Context, arg UpdateScheduledReportParams) (ScheduledReport, error) {
	row := q.db.QueryRowContext(ctx, updateScheduledReport,
		arg.ID,
		arg.OrgID,
		arg.Name,
		arg.ScheduledTime,
		arg.Timezone,
		arg.NextRunAt,
		arg.SeverityThreshold,
		pq.Array(arg.WatchlistIds),
		arg.SendOnEmpty,
		arg.AiSummary,
		arg.Status,
	)
	var i ScheduledReport
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.ScheduledTime,
		&i.Timezone,
		&i.NextRunAt,
		&i.LastRunAt,
		&i.SeverityThreshold,
		pq.Array(&i.WatchlistIds),
		&i.SendOnEmpty,
		&i.AiSummary,
		&i.Status,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
