// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: watchlist.sql

package store

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countOwnedWatchlistsByIDs = `-- name: CountOwnedWatchlistsByIDs :one
SELECT COUNT(*) FROM watchlists
WHERE id = ANY($1::uuid[]) AND org_id = $2 AND deleted_at IS NULL
`

type CountOwnedWatchlistsByIDsParams struct {
	Column1 []uuid.UUID
	OrgID   uuid.UUID
}

// Validates that all given watchlist IDs belong to the org and are not deleted.
// Returns the count of owned watchlists; caller checks count == len(ids).
func (q *Queries) CountOwnedWatchlistsByIDs(ctx context.Context, arg CountOwnedWatchlistsByIDsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOwnedWatchlistsByIDs, pq.Array(arg.Column1), arg.OrgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWatchlistItems = `-- name: CountWatchlistItems :one
SELECT COUNT(*) FROM watchlist_items
WHERE watchlist_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountWatchlistItems(ctx context.Context, watchlistID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWatchlistItems, watchlistID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWatchlist = `-- name: CreateWatchlist :one

INSERT INTO watchlists (org_id, group_id, name, description)
VALUES ($1, $2, $3, $4)
RETURNING id, org_id, group_id, name, description, created_at, updated_at, deleted_at
`

type CreateWatchlistParams struct {
	OrgID       uuid.UUID
	GroupID     uuid.NullUUID
	Name        string
	Description sql.NullString
}

// ABOUTME: sqlc queries for watchlist and watchlist item management.
// ABOUTME: All watchlist operations are org-scoped via org_id parameter.
func (q *Queries) CreateWatchlist(ctx context.Context, arg CreateWatchlistParams) (Watchlist, error) {
	row := q.db.QueryRowContext(ctx, createWatchlist,
		arg.OrgID,
		arg.GroupID,
		arg.Name,
		arg.Description,
	)
	var i Watchlist
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.GroupID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createWatchlistItem = `-- name: CreateWatchlistItem :one
INSERT INTO watchlist_items (watchlist_id, org_id, item_type, ecosystem, package_name, namespace, cpe_normalized)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, watchlist_id, org_id, item_type, ecosystem, package_name, namespace, cpe_normalized, created_at, deleted_at
`

type CreateWatchlistItemParams struct {
	WatchlistID   uuid.UUID
	OrgID         uuid.UUID
	ItemType      WatchlistItemType
	Ecosystem     sql.NullString
	PackageName   sql.NullString
	Namespace     sql.NullString
	CpeNormalized sql.NullString
}

func (q *Queries) CreateWatchlistItem(ctx context.Context, arg CreateWatchlistItemParams) (WatchlistItem, error) {
	row := q.db.QueryRowContext(ctx, createWatchlistItem,
		arg.WatchlistID,
		arg.OrgID,
		arg.ItemType,
		arg.Ecosystem,
		arg.PackageName,
		arg.Namespace,
		arg.CpeNormalized,
	)
	var i WatchlistItem
	err := row.Scan(
		&i.ID,
		&i.WatchlistID,
		&i.OrgID,
		&i.ItemType,
		&i.Ecosystem,
		&i.PackageName,
		&i.Namespace,
		&i.CpeNormalized,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWatchlist = `-- name: GetWatchlist :one
SELECT id, org_id, group_id, name, description, created_at, updated_at, deleted_at FROM watchlists
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type GetWatchlistParams struct {
	ID    uuid.UUID
	OrgID uuid.UUID
}

func (q *Queries) GetWatchlist(ctx context.Context, arg GetWatchlistParams) (Watchlist, error) {
	row := q.db.QueryRowContext(ctx, getWatchlist, arg.ID, arg.OrgID)
	var i Watchlist
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.GroupID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getWatchlistItem = `-- name: GetWatchlistItem :one
SELECT id, watchlist_id, org_id, item_type, ecosystem, package_name, namespace, cpe_normalized, created_at, deleted_at FROM watchlist_items
WHERE id = $1 AND watchlist_id = $2 AND org_id = $3 AND deleted_at IS NULL
LIMIT 1
`

type GetWatchlistItemParams struct {
	ID          uuid.UUID
	WatchlistID uuid.UUID
	OrgID       uuid.UUID
}

func (q *Queries) GetWatchlistItem(ctx context.Context, arg GetWatchlistItemParams) (WatchlistItem, error) {
	row := q.db.QueryRowContext(ctx, getWatchlistItem, arg.ID, arg.WatchlistID, arg.OrgID)
	var i WatchlistItem
	err := row.Scan(
		&i.ID,
		&i.WatchlistID,
		&i.OrgID,
		&i.ItemType,
		&i.Ecosystem,
		&i.PackageName,
		&i.Namespace,
		&i.CpeNormalized,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteWatchlist = `-- name: SoftDeleteWatchlist :exec
UPDATE watchlists
SET deleted_at = now()
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
`

type SoftDeleteWatchlistParams struct {
	ID    uuid.UUID
	OrgID uuid.UUID
}

func (q *Queries) SoftDeleteWatchlist(ctx context.Context, arg SoftDeleteWatchlistParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteWatchlist, arg.ID, arg.OrgID)
	return err
}

const softDeleteWatchlistItem = `-- name: SoftDeleteWatchlistItem :exec
UPDATE watchlist_items
SET deleted_at = now()
WHERE id = $1 AND watchlist_id = $2 AND org_id = $3 AND deleted_at IS NULL
`

type SoftDeleteWatchlistItemParams struct {
	ID          uuid.UUID
	WatchlistID uuid.UUID
	OrgID       uuid.UUID
}

func (q *Queries) SoftDeleteWatchlistItem(ctx context.Context, arg SoftDeleteWatchlistItemParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteWatchlistItem, arg.ID, arg.WatchlistID, arg.OrgID)
	return err
}

const updateWatchlist = `-- name: UpdateWatchlist :one
UPDATE watchlists
SET name        = $3,
    description = $4,
    group_id    = $5,
    updated_at  = now()
WHERE id = $1 AND org_id = $2 AND deleted_at IS NULL
RETURNING id, org_id, group_id, name, description, created_at, updated_at, deleted_at
`

type UpdateWatchlistParams struct {
	ID          uuid.UUID
	OrgID       uuid.UUID
	Name        string
	Description sql.NullString
	GroupID     uuid.NullUUID
}

func (q *Queries) UpdateWatchlist(ctx context.Context, arg UpdateWatchlistParams) (Watchlist, error) {
	row := q.db.QueryRowContext(ctx, updateWatchlist,
		arg.ID,
		arg.OrgID,
		arg.Name,
		arg.Description,
		arg.GroupID,
	)
	var i Watchlist
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.GroupID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
